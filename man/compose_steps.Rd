% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/universe.R
\name{compose_steps}
\alias{compose_steps}
\title{Convert a named list of step functions into a composition}
\usage{
compose_steps(steps, cache = NULL, select = last)
}
\arguments{
\item{steps}{A named list of functions.}

\item{cache}{A step cache as generated by \code{make_cache}.}

\item{after}{A function to run after the steps of the pipeline. The default
\code{last} should usually be left as-is.}
}
\value{
A function with signature \code{analysis(list_of_args)}
}
\description{
Turns a list of functions into a pipeline that accepts a list of
arguments (e.g. a scenario from a multiverse specification produced with
\code{fork::fork}, or more generally a row from a data frame) and produces
the result of running each function on the input to the pipeline, merged
with the output of the previous function.

In technical terms, in addition to creating the composition, this function
also enhances the original step functions so that they report improved
error messages (with \code{fork::rethrow_with_args}), accept individual function
arguments instead of a list of arguments (with \code{fork::unsplat}), modify the
input with the output (with \code{fork::modifier}) and cache the output (with
\code{fork::cached}) if desired. All of this considerably easier to understand
in the context of an example.

Because the pipeline unsplats function arguments, it becomes easy to test
each step individually, with natural function signatures, even though behind
the scenes each function accepts a list and returns a list.
}
\examples{
scenarios <- expand_grid(
  add = 1:3,
  multiply = 1:3
)
steps <- list(
  add = function(add, ...) {
    list(
      sum = 10 + add
    )
  },
  multiply = function(sum, multiply, ...) {
    list(result = tibble(
      sumprod = sum * multiply
    ))
  }
)

analyze <- compose_steps(steps, cache = NULL)

# we'll create a cache but refrain from using it for now
cache <- make_cache(steps)
analyze_and_cache <- compose_steps(steps, cache = cache)

result <- analyze(add = 1, multiply = 2)
expect_equal(result, 22)

results <- scenarios |> row_modify(analyze)
expect_equal(results$sumprod, c(11, 22, 33, 12, 24, 36, 13, 26, 39))
}
