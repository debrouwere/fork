# Simple step cache
#
# We cache the steps of a process, and then for any subsequent similar process
# we use the cache of the last step before the process diverges. Only one
# process is cached at any time, so this cache relies on a good ordering of the
# processes (last step changest fastest) to function effectively.

library("stringr")

#' Test for absence of NAs
#'
#' (Can probably be replaced with `compose(!, anyNA)`.)
#'
#' @description Essentially `!anyNA`
#'
#' @param x
#'
#' @return A logical value, `TRUE` or `FALSE`
#' @export
exists <- function(x) {
  !any(is.na(x))
}

#' is_needed
#'
#' #' @description
#' we assume that a step that has multiple parameters, contained within a df-column,
#' will describe in its first sub-column whether the analysis is needed;
#' this is naturally what `pack_by_sep` will do if a <step> variable is defined before
#' any <step>_<parameter> variables, but still good to keep in mind;
#' this function also works with regular columns
#'
#' @param x
#'
#' @return A logical value, `TRUE` or `FALSE`
#' @export
is_needed <- function(x) {
  !(is.na(x[[1]]) | x[[1]] == FALSE)
}

#' Initialize a simple step cache
#'
#' @param scenarios
#'
#' @return A cache environment.
#' @export
make_cache <- function(scenarios) {
  # possibly could also save the steps to an `attr`
  # so that, if any direct access to the cache is needed,
  # it is less verbose
  steps <- dotnames(scenarios)
  cache <- as.list(rep(NA, length(steps)))
  names(cache) <- steps
  slots <- list2env(cache)
  attr(slots, "steps") <- steps
  slots
}

#' Invalidate the step cache from a particular step onwards
#'
#' @description The step cache is invalidated in-place, not in a copy.
#'
#' @param cache A simple step cache as made by `make_cache`
#' @param start_at_ix The step index from which to invalidate
#'
#'
#' @return The partially invalidated cache.
#' @export
invalidate_cache <- function(cache, start_at_ix = 1) {
  steps <- attr(cache, "steps", exact = TRUE)
  n <- length(steps)
  for (i in start_at_ix:n) {
    name <- steps[i]
    cache[[name]] <- NA
  }

  cache
}

noop <- function(input) {
  input
}

#' Create a `step` function that is aware of the cache and the active scenario.
#'
#' @description The `step(name, fn)` function created by this factory will query
#'   the cache to see whether execution is necessary, and if it is, pass the
#'   output from the previous step to `fn`, which will in turn be cached.
#'
#' @param scenario One scenario, usually from a tibble of scenarios generated with `grid` and `fork`.
#' @param cache A step cache as generated by `make_cache`.
#'
#' @return A function with signature `step(name, fn)`
#' @export
#'
#' @examples
#' scenarios <- expand_grid(add=1:3, multiply=1:3)
#' cache <- make_cache(scenarios)
#' output <- lapply(1:nrow(scenarios), function(i) {
#'   step <- step_through(scenario, cache)
#'   step('add', function(input) {
#'     10 + scenario$add
#'   })
#'   step('multiply', function(input) {
#'     input * scenario$multiply
#'   })
#'   return(cache$multiply)
#' }
step_through <- function(scenario, cache) {
  function(name, processor) {
    steps <- attr(cache, "steps", exact = TRUE)
    curr_ix <- which.max(steps == name)
    curr <- steps[curr_ix]
    prev_ix <- curr_ix - 1
    prev <- steps[prev_ix]

    cache[[curr]] <- if (!all(is.na(cache[[curr]]))) {
      cache[[curr]]
    } else {
      input <- if (prev_ix > 0) {
        cache[[prev]]
      } else {
        NA
      }
      process <- if (is_needed(scenario[[curr]])) {
        processor
      } else {
        noop
      }
      process(input)
    }
  }
}
